## 여행 경로

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
| [프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/43164)|여행 경로|Lv.3|

보기에서 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 하도록 되어 있기에, 경로 추적 전에 배열을 문자열 기준으로 정리하고 시작하였음. 

테스트 3, 테스트 4는 무난히 통과했지만, 테스트 1, 테스트 2에서 어려움을 겪었음. 테스트 케이스에 대한 인사이트를 얻은 뒤, 문제를 해결.

### 풀이
단순한 접근은 굉장히 쉬워보이나, 테스트 1, 테스트 2에 대한 테스트 케이스를 생각하기 어려웠음. 

```
[ICN, BBB], [ICN, AAA], [BBB, ICN]
```
위와 같은 테스트 케이스가 존재할 때, 내 코드의 흐름대로 정렬을 진행하면 다음과 같이 정렬됨.

```
[BBB, ICN], [ICN, AAA], [ICN, BBB]
```

이 때 `[ICN, AAA]`가 `[ICN, BBB]`보다 우선 순위이기 때문에 `[ICN, AAA]`를 기준으로 추적을 시작함. 하지만 연결되는 항공편이 없어, 빈 배열이 return 됨. 하지만 다음과 같은 결과가 나와야 함

```
[ICN, BBB, ICN, AAA]
```

단순히 문자열을 기준으로 정렬하는 것이 아니라, 항공편을 추적할 수 있는 모든 방법 중에 항공편이 중복되는 것이 있다면 그 중 알파벳을 오름차순 정렬하여 된 것을 정답으로 간주함. 그렇기 때문에 하나의 케이스만을 DFS에 넣는 것이 아니라, 일단은 만족하는 모든 것을 DFS에 넣고, 그 중 가장 처음으로 만족하는 것을 return 시킴. 왜냐하면 정렬을 먼저 시켜놓았기 때문에 가장 먼저 모든 항공편을 들리는 루트가 정답이 됨.

