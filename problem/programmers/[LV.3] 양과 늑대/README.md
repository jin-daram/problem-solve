## 양과 늑대

|풀이 사이트|문제 이름|난이도|비고|
|:---:|:---:|:---:|:---:|
[프로그래머스]()|양과 늑대|Lv.3|2022 KAKAO BLIND RECRUITMENT|

### 풀이
조금 어려워서 AI의 힌트를 받았던 문제이다. 예제를 기준으로 설명했을 떄, `0 -> 1`로 이동했을 때, 양의 수는 2마리가 된다. 그리고 `노드 1번`에서 이동할 수 있는 경우의 수는 2번, 4번 그리고 0번 노드이다. 하지만 0번 노드를 방문하는 것은 의미가 없다. 그래도 코드 상 0번을 방문하고, 이미 방문한 노드라면 양의 수를 더하지 않는 방향으로 생각했지만 너무 복잡해져 생각을 코드를 마무리 지을 수 없었고, 마무리 지었던 코드는 기대한 정답을 내놓지 못했다. 

문제를 풀이하는 방식은 이렇다. `0 -> 1`로 이동했을 때, `1번 노드`에서 이동할 수 있는 노드는 각각 `2번`, `4번`, `8번` 노드이다. 

이러한 방문 가능한 노드의 경우의 수는 `현재 방문한 노드` +` 이전 노드에서 방문 가능한 노드의 수 (현재 노드를 제외한)`

예를 들어 `1번 노드`에서 방문 가능한 수는 
- **이전 노드에서 방문 가능한 노드의 수 (현재 노드 제외)** : `8번`
- **현재 노드에서 방문 가능한 수** : `2번`, `4번`

이런식으로 된다. 여기서 하나씩 방문하여 양을 만나면 `sheep`의 수를 증가시키면 된다. 하지만 주의 해야할 점이 있다. 

만약 `0 -> 1 -> 2` 라는 방식으로 방문하게 되면, 2번 노드는 자식 노드가 없기 때문에 방문 가능한 노드가 `4번`, `8번` 노드가 된다. 그리고 `4번 노드`로 이동하게 되면 늑대의 수가 같아져, 잡아 먹히게 된다. 그러면 다시 `1번 노드`에서부터 방문 가능한 경우의 수를 찾아야 하는데, 이 때 방문 했던 `2번 노드`가 경우의 수에서 사라지는 게 아닌 그대로 유지되어야 한다. 즉 4번 노드를 방문 하되, 나머지 방문 가능한 노드인 `2번`, `8번` 노드는 유지되어야 한다.

나는 이 점을 유지하기 위해 다음과 같이 코드를 짰다.

```java
// 다음 방문할 노드 추출
int nextNode = visitableNodes.get(i);
List<Integer> newVisitableNodes = new ArrayList<>();

// (방문 가능한 노드 - 다음에 방문할 노드)
for (Integer visitableNode : visitableNodes) {
    if (nextNode != visitableNode) {
        newVisitableNodes.add(visitableNode);
    }
}

// 다음 방문 할 노드의 자식 노드 추가
for (int k=0; k<tree.length; k++) {
    if (tree[nextNode][k] != 0) {
        newVisitableNodes.add(k);
    }
}

if (I[nextNode] == 0) dfs(nextNode, newVisitableNodes, sheep+1, wolf, depth + 1);
else dfs(nextNode, newVisitableNodes, sheep, wolf+1, depth + 1);

```