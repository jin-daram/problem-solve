## 등굣길

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/42898)|등굣길|LV.3|

### 문제 풀이

문제를 처음 보면 BFS나 DFS로 풀 수 있겠다는 생각이 든다. 전형적인 2차원 배열에서 각 지점을 방문하는 최대 경우의 수를 푸는 방법이다. BFS/DFS도 그리 어렵지 않게 구현할 수 있다. 나도 처음에 DFS로 문제를 풀었다. 하지만 채점 했을 때, 시간 초과가 나서 아예 다른 방법으로 접근해서 풀어야 겠다고 생각했다. 그게 이 문제의 핵심같다. 

어떻게 보면 [백준 - [부녀회장이 될테야]](../../boj/[브론즈1]%20부녀회장이%20될테야/README.md) 문제와 유사하다. DP 문제를 풀 때 가장 먼저 DP 배열에 무엇을 담을건지 생각해본다. 주어진 2차원 배열에서 각 지점으로 최소로 이동할 수 있는 개수는 정해져있다. 

```
// H: 집, S: 학교
[H][ ][ ]
[ ][ ][S]
```

와 같이 주어졌을 때, `[1, 2]`, `[2, 1]` 지점을 최소로 방문하는 방법의 개수는 모두 1가지 방법 뿐이다. `[3,1]` 은 어떨까? 물론 1가지이다. 여기서 어떠한 패턴을 찾을 수 있다. **집으로 부터 직선 거리에 있는 모든 지점들을 최소로 갈 수 있는 방법은 모두 1가지다.**

또한 문제에서 반드시 오른쪽과 아래쪽으로만 이동할 수 있다고 했다. 그렇다면 어떠한 지점을 방문하는 방법은 `오른쪽(➡️)` 으로 이동해서 방문하거나, `아래(⬇️)`로 이동해서 방문하는 방법 뿐이다. 그리고 직선 거리에서 최소로 이동할 수 있는 방법은 모두 같다고 했다. 즉 방향이 바뀌어야 지점을 도달하는 새로운 방법이 생긴다는 것이다.

이를 바탕으로 점화식을 세우게 된다면

```
dp[i][k] =  dp[i-1][k] + dp[i][k-1]
```

와 같이 세울 수 있다. 하지만 문제에서는 추가적으로 장애물이 주어진다. **장애물이 막고있다면 진행방향의 직선에 있는 모든 지점에 도달할 수 없다.**

만약 `i`가 `0~N` 혹은 `0~M` 까지 증가한다고 했을 때, `dp[i][1]`, `dp[1][i]` 범위에 장애물이 생기는 경우, 그 이상의 지점에는 도달할 수 없다.

```
// W: 장애물, X: 도달할 수 없는 지점
[H][ ][ ][W][X][X]
[ ][ ][ ][ ][ ][ ]
[W][ ][ ][ ][ ][ ]
[X][ ][ ][ ][ ][ ]
[X][ ][ ][ ][ ][S]
```

이러한 경우 해당 지점을 `0`으로 설정해두면 점화식에서도 문제 없이 정상적인 케이스로 계산할 수 있다.

이런 세세한 문제의 요구사항을 만족해야 하기 때문에 DP[] 배열을 설정할 때, 해당 조건을 잘 생각하고 설정하여야 한다.