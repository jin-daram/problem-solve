## 경주로 건설

|풀이 사이트|문제이름|난이도|비고|
|:---:|:---:|:---:|:---:|
| [프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/67259)|경주로 건설|Lv.3|2020 카카오 인턴십|


### 풀이

단순한 BFS와 같아 보이지만, 최단 거리가 아닌 최단 비용이라는 것을 계산해야 한다. 같은 거리를 가더라도, 코너가 발생하면 비용이 더 든다. 이 점은 같은 위치에 도달하였더라도, 비용에 대해서 많은 차이가 발생할 수 있다. 다음을 예로 들어보자.

```
[n][ ][ ]
[ ][ ][ ]
[ ][ ][m]
```
n에서 m으로 가고자 할 때, 최소 4칸을 이동해야 한다. 


```
[n][O][O]
[ ][ ][O]
[ ][ ][m]
```

`O`를 통해 지나는 것에 대한 비용은 `직선 비용 400` + `코너 비용 500` 으로 총 `900`이다.
다음 경로를 살펴보자.

```
[n][O][ ]
[ ][O][O]
[ ][ ][m]
```

조금 특이한 경로지만 이동한 칸 수는 4칸이고 목적지도 똑같다. 하지만 비용은 `직선 도로 4개 400` + `코너 도로 3개 1500` 으로 총 `1900`의 비용이 발생한다. 

즉, 이동 방향에 따라서 비용이 같은 위치라도 달라질 수 있기 때문에 다르게 계산해야 한다. 여기서 3차원 배열이 필요해진다.

```java
// mx: 최대 X, my: 최대 Y
// 4 = (동,서,남,북)의 방향값
int[][][] visited = new int[mx][my][4]
```

풀이의 핵심은 방향에 따라 어떤 지점을 도착했을 떄, `visited` 배열에 방향과 위치 정보와 함께 해당 지점까지 들었던 비용을 저장하는 것이다.

```java
// 상:0, 하:1, 좌:2, 우:3
int newCost = currentRoad.cost + 
          (currentRoad.dir == -1 || currentRoad.dir == dir ? 100 : 600);

if (visited[nx][ny][dir] > newCost) {
    visited[nx][ny][dir] = newCost;
    queue.offer(new Road(nx, ny, dir, newCost));
}

```

이런식으로 진행하게 되면 방향에 따른 모든 지점에 대한 비용을 저장할 수 있다. 이전에 `visited` 배열은 배열의 요소가 모두 `Integer.MAX_VALUE`로 초기화 돼있어야 계산이 편해진다. 사실 BFS는 이 문제를 풀기 위한 탐색 방법일 뿐, 전체 경로의 경우의 수를 계산하여야만 한다. 이 때 경로를 탐색했을 때의 상태 관리가 중요하다. 

해당 문제는 시간을 두고 나중에 다시 풀어봐야겠다.