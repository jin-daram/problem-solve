## 사전

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/1256)|사전|골드 2|

### 문제 풀이

> 재풀이 필요

정답을 보진 않았지만, 접근에 대한 힌트를 조금 얻고 풀었던 문제이다. 처음에는 3차원 배열을 통해 문제를 풀어야겠다고 생각했다.
가로축과 세로축을 각각 `a`의 개수, `z`의 개수로 설정하고, 그 안에 순서대로의 조합이 들어있는 형태의 배열을 생각했다. 그렇게 dp[N][M] 까지 쭉 구하고 나서, 섞인 조합의 형태를 정렬하면 된다고 생각했다. 하지만 마지막 배열에 너무 많은 조합이 담길 수 있으므로 시간 초과가 나는 방법이었다. 그래서 다른 방법을 생각해야 했다.

맨 처음에 올 수 있는 문자는 `a` 혹은 `z`이다. 그리고 그 다음에 올 수 있는 문자도 `a`혹은 `z`이다. N과 M이 주어지고, K까지 주어졌을 때, K번째에 해당하는 문자를 구할 때, 우리는 dp[N][M]에 대한 총 조합의 개수가 있으면 K번쨰가 어떤 문자인지 확인할 수 있다.

다음 예시를 살펴보자.

`N=2`, `M=2`, `K=5`
`dp[i][k]`에서 `i`를 `z의 개수` `k`를 `a의 개수` 라고 가정 했을 때, 해당 조합을 총 개수를 `dp[i][k]` 로 표현할 수 있다. 

`dp[1][1]`은 `az`, `za`가 있으므로 `2`이다. 
`dp[2][1]`은 `azz`, `zaz`, `zza`로 `3`이다.
`dp[1][2]`은 `aaz`, `aza`, `zaa`로 `3`이다.

이런식으로 계속 구해보다 보면 규칙이 보인다. 각각의 조합들이 `a`로 시작한다면 그 뒤에 나오는 조합의 개수는 `dp[i][k-1]` 개의 조합과 같다. 왜냐하면 
`a=2`, `z=1` 라고 했을 때, 맨 앞에 a가 나오면 그 뒤에는 `a개 1개`, `z가 2개` 나와야 하니까 말이다. 이런 방식을 점화식으로 구성하면 다음과 같다.

```
dp[i][k] = dp[i-1][k] = dp[i][k-1]
```

이런식으로 구하면 `dp[i][k]`의 총 조합의 개수를 확인할 수 있다. 그러면 여기서 처음에 `dp[i][k]` 조합 중에서 `a`가 처음으로 시작하는 조합은 몇 개인가 라고 생각했을 떄, 그건 바로 `dp[i][k-1]`이다. DP 점화식 자체가 그렇게 구성되어있으니까 말이다. 이런식으로 계속해서 풀어가면 `dp[N][M]` 일 떄의 총 조합의 개수와 `a로 시작하는 조합의 개수`, `z로 시작하는 조합의 개수` 를 구할 수 있다.

코드로 구현한 **점화식**은 다음과 같다.

```java
for (int i = 1; i <= M; i++) {
    for (int k = 1; k <= N; k++) {
        dp[i][k] = Math.min(1_000_000_001L, dp[i - 1][k] + dp[i][k - 1]);
    }
}
```

> ```Math.min(1_000_000_001L, ... )``` 을 하는 이유는 `K`의 범위는 `1,000,000,000` 까지 입력 받을 수 있다. 하지만 점화식을 이용해 DP를 계산하다보면 조합의 개수가 K의 범위를 넘을 경우, `-1`을 출력하도록 유도하는 코드이다.

위와 같은 점화식으로 DP를 모두 다 구했다면 이제 `총 조합의 개수`와 `a로 시작하는 조합의 개수`를 이용하여 사전의 K번째 문자를 구할 수 있다.

게속해서 K번째 문자를 추적하다가 끝을 만날 수 있다. 그 경우는 `dp[1][1]`이 되었을 떄 `az` or `za`를 붙이는 것과, `dp[0][k]`, `dp[i][0]` 을 만났을 때, 연속된 문자를 추가하는 경우가 있다. 이 경우 지속적으로 `K`를 감소시킨 값에 따라 처리하도록 하고, 0 으로 끝나는 경우에는 `k`와 `i`번 만큼 문자를 더해주도록 한다. 

코드를 보면 바로 이해 할 수 있다.

```java
...
if (a == 0 || z == 0) {
    if (a == 0) {
        for (int i=0; i<z; i++) {
            result.append("z");
        }
    } else {
        for (int i=0; i<a; i++) {
            result.append("a");
        }
    }
    break;
} else if (z == 1 && a == 1) {
    if (K == 2) {
        result.append("za");
    } else {
        result.append("az");
    }
    break;
...
```

위와 같은 경우를 만나면 반복문을 종료하면 된다.

그 다음은 일반적인 경우이다. 맨 앞에 `a`가 오는지 `z`가 오는지 판단하여 `StringBuilder`에 문자를 추가하고, K 값을 갱신하는 해야한다.
```java
if (dp[z][a-1] >= K) { // a를 추가하는 케이스
    result.append("a"); 
    a = a - 1;
} else if (dp[z][a-1] < K) { // z를 추가하는 케이스
    result.append("k");
    K = K - dp[z][a-1];
    z = z - 1;
}
```

이제 위 과정을 거쳐 생성된 **result**를 출력하면 된다.