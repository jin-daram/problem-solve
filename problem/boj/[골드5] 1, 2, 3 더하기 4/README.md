## 1, 2, 3 더하기 4

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/15989)|1, 2, 3 더하기 4|골드 5|

### 문제 풀이

[동전 1](https://www.acmicpc.net/problem/2293) , [동전 2](https://www.acmicpc.net/problem/2294) 문제와 비슷한 DP 문제이다. `KnapSack Problem` 알고리즘을 통해서 풀 수 있다. 문제에서는 테스트케이스가 주어지기 때문에 N의 최대의 수는 `10000` 이기 때문에 `dp[10000]` 까지 모두 구한 후, 사용자의 입력을 받아서 `dp[N]`을 반환하도록 구현했다.

먼저 `dp[1]`은 모두 `1`로 설정한다. `1` 만을 사용해서 어떤 수 `N`을 만드는 방법은 모두 `1가지`이기 때문이다.

`dp[2]` 부터는 `dp[1]`의 값을 이용해야 한다. 먼저 1과 2를 통해 숫자 3을 만드는 방법의 경우는 다음과 같다.

```
1+1+1
1+2 (2+1)
```

`1+1+1`은 dp[1]에서 설정한 값이고, 1+2에서 1은 dp[1]에서 숫자 1을 만드는 경우이다. 즉 dp[3]은 `1로 3을 만드는 가짓 수 (1)` + `1과 2로 3을 만드는 가짓 수 (1)` 가 된다. 이 때 `1과 2로 3을 만드는 가짓수` 는 값이 `1인 것에 2를 더하는 경우이다.`

그렇기 때문에 점화식은 다음과 같다.

```
// number은 추가된 수이다. (number >= 2)
dp[i] = dp[i] + dp[i-number];
```

이 때 `number`과 `i`가 같은 경우에는 그저 `dp[i]`에 `+1`을 한다.