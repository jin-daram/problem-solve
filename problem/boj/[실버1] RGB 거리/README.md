## RGB 거리

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/1149)|RGB 거리|실버 1|

### 문제 풀이

각각의 집을 칠했을 때, 조건을 만족하면서 비용이 최소가 될 때, 모든 집을 칠할 때, 최소 비용을 구하는 문제다. 먼저 DP 배열에 어떤 값을 담을 지 정해야 한다.
처음에는 단순히 dp[i]는 i번째 집을 칠했을 때, 최소 비용 값을 저장하는 것은 단순하게 생각했다. 하지만 그렇게 dp[i]의 값을 구하는 것이 복잡하고 힘들었다. 그래서 조금 시선을 바꿔서 DP를 2차원 배열로 선정하고, `dp[i][k]`에 대해 `k = 0 ~ 2` 까지 있고, `0 = R`, `1 = G`, `2 = B`로 정했다. 그리고 `i는 i번째의 집`을 의미한다. 즉 `dp[i][k]`값은 i번쨰의 집을 R, G, B로 각각 칠했을 때의 최소 값이다. 만약 2번째의 집을 R로 칠했을 때의 최소값은 `min(2번째 집을 R로 칠하는 비용 + 1번째 집을 G로 칠하는 비용, 2번째 집을 R로 칠하는 비용 + 1번째 집을 B로 칠하는 비용)` 이다. 즉 둘 중의 최소값이 2번째 집을 R로 칠하는 비용의 최소값이다. 

이런식으로 문제를 푼다면 마지막 N번째 집을 R,G,B로 칠하는 각각의 최소값을 구하고, 가장 작은 값을 출력하면 된다. 

위 흐름을 점화식으로 구성하면 다음과 같다.

```java
/* value[][]는 각각의 i번째 집에 따른 RGB 비용은 담은 2차원 배열 */

// 이번 집을 R로 칠하는 경우
dp[i][0] = Math.min(value[i][k] + dp[i-1][1], value[i][k] + dp[i-1][2]);

// 이번 집을 G로 칠하는 경우
dp[i][1] = Math.min(value[i][k] + dp[i-1][0], value[i][k] + dp[i-1][2]);

// 이번 집을 B로 칠하는 경우
dp[i][1] = Math.min(value[i][k] + dp[i-1][0], value[i][k] + dp[i-1][1]);
```

`dp[N][0]`이 가질 수 있는 최소값은 이전 `dp[N-1]`의 `[1]`과 `[2]` 중 최소가 되는 값이다. 이는 `dp[N][1]`와 `dp[N][2]` 마찬가지이다.

이렇게 여러개의 경우의 수가 있는 경우에는 각각의 케이스에 대해 최소값을 가지는 `DP 배열`을 각각 구성해서 풀면 좋을 것 같다. 너무 단순하게 접근하기 보다 문제를 작은 것으로 치환하여 푸는 방법을 생각하는 연습을 하면 좋을 것 같다. 