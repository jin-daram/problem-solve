## 이동하기

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/11048)|이동하기|실버 2|

미로에서 (1, 1)를 기점으로 `오른쪽`, `아래`, `오른쪽 아래` 로만 움직일 수 있고, 각 칸에 사탕 여러개가 주어진다. 

미로의 오른쪽 아래 `(N, M)` 에 도착했을 때, 사탕 개수의 최대 값을 구해야 한다.

이는 DP 배열의 각 칸에 도달했을 때, 사탕의 `최대값`을 구해야 한다. 즉 `dp[2][2]`는 `(2, 2)`로 이동 했을 때, 사탕 `최대값`이다. 

이는 `(2, 2) 사탕의 개수` + `dp[1][1]` or `dp[1][2]` or `dp[2][1]` 중 `최대값`을 구하면 된다. 이렇게 계속해서 왼쪽 위부터 오른쪽 아래대로 값을 구해나가면 `dp[N][M]`에 도달했을 때, 구할 수 있는 사탕의 최대값을 구할 수 있다.


**주어진 예제** 

```
1 2 3 4
0 0 0 5
9 8 7 6
```

아래는 `주어진 예제`를 바탕으로 DP 배열의 값을 구한 것이다. 이를 편하게 구하기 위해서 `dp[0][i]`와 `dp[i][0]`의 값들은 모두 구하고 `dp[2][2]` 부터 반복문을 통해 구하면 값을 편하게 구할 수 있다.

```
1  3  6  10
1  3  6  15
10 18 25 31
```

핵심 코드는 다음과 같다.

```java
int currentCandy = map[i][k];
dp[i][k] = currentCandy + dp[i-1][k-1];
dp[i][k] = Math.max(dp[i][k], currentCandy + dp[i-1][k] );
dp[i][k] = Math.max(dp[i][k], currentCandy + dp[i][k-1]);
```