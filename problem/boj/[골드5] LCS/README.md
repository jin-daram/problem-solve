## LCS

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/9251)|LCS|골드 5|

### 문제 풀이

> 예전에 고민하다가 못 풀고 다시 풀어보자고 기록한 문제이다. 다시 풀긴 했지만, 핵심적인 부분에 대해 착오가 있어서 다시 힌트를 보고 풀었다. 시간이 지나면 또 다시 풀어볼만한 문제이니, [다시 풀어볼 문제](../README.md)에 추가하였다. 

두 문자열 A, B가 주어졌을 때, 두 문자열 간의 가장 긴 부분 공통 수열을 찾는 것이다. 예를 들어 다음과 같은 두 문자열이 주어졌다.

```
ACAYKP
CAPCAK
```

이 때, LCS는 바로 ACAK이다. 바로 이런 수열 중 가장 길이가 긴 두 문자열 간의 공통 부분 수열을 구하는 것이다. 나는 2차원 DP 배열을 구성해서 풀었다.
`dp[i][k]`는 `i번째 문자`까지와 `k번째 문자`까지의 최장 부분 공통 수열의 길이이다. 예를 들어 위 예제를 기반으로 `dp[3][3]`은 `ACA`, `CAP` 간의 최장 부분 공통 수열의 길이라고 보면 된다. 그래서 dp[3][3]의 값은 `CA` 가 양쪽 수열에 모두 존재하고, 가장 긴 공통 부분 수열이므로, `2`이다.

위와 같은 방식은 시간 복잡도가 `첫번쨰 문자열 길이 * 두번쨰 문자열 길이` 만큼 걸린다. 그래서 효율적으로 DP를 활용하여 정답을 구할 수 있다.

먼저 `dp[1][i]`의 값은 먼저 세팅할 수 있다. 같은 문자가 나오기 전까지 `0`을 넣고, 나왔다면 그 문자를 포함하여 그 이후 문자의 자리까지도 `1`로 채우면 된다.
그리고 그 다음 배열부터는 만약 문자가 같다면 `dp[i][k] = dp[i-1][k-1] + 1`로 값을 저장해주면 된다. 

하지만 나는 처음에 단순하게 `dp[i][k] = dp[i-1][k]` 로 값을 저장하여 풀었다. 명확한 기준이 있었던 것은 아니고, 각각의 문자가 같다면, second 문자열을 하나뺀 것에서 방법을 하나 더 한다는 것이다. 쉽게 예를 들어보겠다.

```
ABCE
BCEE
```

와 같은 문자열이 주어졌을 떄, 첫번째 문자열이 가로축, 두번쨰 문자열이 세로축이락 ㅗ가정하자.

```
0 1 1 1
0 1 2 2
0 1 2 3
0 1 2 4
```

`마지막 배열의 4번쨰 요소의 값 (4)` 가 이상하다. 정답은 3이 나와야 한다. 하지만 `dp[i][k] = dp[i-1][k] + 1` 로 계산하니 정답이 이상하게 나왔다. 이는 중복이 개선되지 않은 문제이다. 문자가 같다고 길으를 추가하려고 할 때, 그 추가 이전의 값은 그 문자가 추가되기 전이 기준이어야 한다. 하지만 나는 두번째 마지막 문자 `E`의 경우에만 추가되기 전으로 설정하고, 첫 번째 문자열의 `E`는 포함된 상태로 문자열을 추가했다. 

그렇다면 나는 
```
ABCE
BCE
```
의 기준에서 길이를 하나 더 추가하게 된 것이다. 이는 중복되는 경우에는 정답이 중복이 계산되지 않고 잘못된 정답이 나올 가능성이 있다. 
올바른 점화식을 세운 코드를 다음과 같다.

```java
for (int k=0; k<first.length(); k++) {
    if (k == 0) {
        int result = target == first.charAt(k) ? 1 : 0;
        dp[i][k] = Math.max(dp[i-1][k], result);
        continue;
    }

    if (target == first.charAt(k)) {
        dp[i][k] = dp[i-1][k-1] + 1;
    } else {
        dp[i][k] = Math.max(dp[i][k-1], dp[i-1][k]);
    }
}
```

`dp[i-1][k] + 1` 와 같은 점화식을 세우게 된 이유가 나는 결과를 올바르게 맞추려고 집중했던 거 같다. 그래서 저 점화식에 대한 잘못된 점을 짚지 못했다. 중복되지 않은 경우, 저 점화식은 정답을 맞출 수 있다. 하지만 중복된 경우가 생겼을 때만 문제가 되는 것이다. 앞으로 결과를 맞추기에만 급급하기 보다, 근본적인 알고리즘 풀이 방법을 생각해내는 연습을 해야겠다.