## 계단 오르기

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2579)|계단 오르기|실버 3|

### 문제 풀이

DP 문제를 풀면서 점화식을 세우는 게 어렵다고 느껴서 전에 풀다가 다음에 다시 풀어보자 하고, 따로 기록하지 않았던 문제이다. 해당 문제에 대해 점화식을 세우는 게 이해되서 글을 남긴다.

점화식을 세울 때, 어떤 요소를 `DP 배열`에 담아야 하는지 생각해야 한다. 즉 어떤 작은 문제를 풀어서 점차 큰 문제를 풀어야 할지를 고민을 해야한다.

`계단 오르기` 문제의 경우 `DP 배열` 에 담아야 하는 값을 `i번째 계단에서 얻을 수 있는 최대 점수`로 풀이할 수 있다.즉 우리가 구하는 것은 N번째 계단에서 구할 수 있는 최대 점수이니까 말이다.

`1번째, 2번째 ... 7번째` 로 점점 작은 문제를 풀면서 큰 문제를 풀어가는 **Dynamic Programming** 방식이다.

이제 DP 배열을 통해 어떤 작은 문제를 풀어야 하는 지 알아봤으니, 작은 문제부터 풀어봐야 한다. 각 i번째에 해당하는 점수를 담은 배열 `stair[i]`가 있다고 했을 때, 직접 계산할 수 있는 i번째의 계단의 값은 다음과 같다.

<i>(입력값은 [계단오르기](https://www.acmicpc.net/problem/2579)에 있는 예제 입력값을 기준으로 설명한다.)</i>
- `dp[0] = 0`
- `dp[1] = 10`
- `dp[2] = 30`

이런식으로 구성할 수 있다. 이제 dp[3]을 구하고자 할 때, 점화식을 세우는 큰 힌트를 얻을 수 있다.
dp[3]을 만들 수 있는 경우의 수는 총 2가지다.

- `1번째 계단` + `3번째 계단`
- `2번째 계단` + `3번쨰 계단`

총 두 가지 경우의 수 중 점수가 더 큰 값이 `dp[3]`에 저장될 값이 된다. 이를 토대로 세 번째 계단에 올랐을 때 최대 점수를 구하는 식을 세울 수 있다.

```
dp[3] = max(dp[1] + stair[3], dp[2] + stair[3])
```

하지만 오류가 생길 수 있는 식이다. 분명 문제의 제한 조건 중 연속해서 3개의 계단을 밟을 수 없다. 하지만 `dp[2] + stair[3]`와 같은 식을 자세히 살펴보면
`dp[2]`는 반드시 2개의 연속된 계단을 밟는다. 그렇기 때문에 dp[2] + stair[3] 이라는 식은 세 개의 계단을 연속해서 밟는 것과 같다. 그래서 다음과 같이 식을 수정해야 한다.

```
dp[3] = max(dp[1] + stair[3], dp[0] + stair[2] + stair[3])
```

`0 번째`는 문제에서는 없지만, 우리가 생각할 때는 `0점`으로 생각할 수 있다. 그래서 3번째 계단에 올랐을 때, 얻을 수 있는 최대 점수를 구할 수 있다. 이제 이를 완벽하게 점화식으로 세워보면

```
dp[i] = max(dp[i-2] + stair[i], dp[i-3] + stair[i-1] + stair[i])
```

이를 코드로 옮기면 다음과 같다.

```java
for (int i=3; i<=N; i++) {
    dp[i] = Math.max(dp[i-2] + stair[i], dp[i-3] + stair[i-1] + stair[i]);
}
```

나는 첫 부분을 계산하는 경우를 통해 구했지만, 끝 부분에서 생각해볼 수도 있다. 마지막 계단은 무조건 밟아야 하기 때문에 stair[N]은 무조건 더해져야 한다. 이러는 상황에서 제한되는 조건을 만족하고 무조건 이루어져야 하는 경우만 점화식을 세우면 된다. 

1. N번째 계단을 2개 연속된 계단으로 오르는 경우
2. N번째 계단을 한 계단 건너 뛰어서 오르는 경우