## 설탕 배달

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2839)|설탕 배달|실버 4|

### 문제 풀이
3kg, 5kg로 구성된 설탕 주머니를 주어진 무게 N만큼 들고가려고 할 때, 들고가는 봉지의 최소 개수를 출력해야 하는 문제이다. 비슷한 문제를 푼 적이 있어서 동일한 방법으로 접근했다.

`DP 배열`에는 증가하는 `i (무게)`에 따른 `주머니를 들고가는 최소 개수` 값을 저장한다.

아래는 `3kg 설탕 주머니`만 돌고갔을 때의 최소 개수이다.
```
무게 [1][2][3][4][5][6][7][8]
개수 [ ][ ][1][ ][ ][2][ ][ ]
```

여기서 `5kg 설탕 주머니`도 같이 들고 갔을 떄의 최소 개수는 다음과 같다.

```
무게 [1][2][3][4][5][6][7][8]
개수 [ ][ ][1][ ][1][2][ ][2]
```

이를 점화식으로 구현하면 

```java
for (int k=number; k<=N; k++) {
    if (dp[k-number] != Integer.MAX_VALUE) {
        dp[k] = dp[k-number] + 1;
    }
}
```

와 같이 구할 수 있다. 이를 성공하기 위해서는 먼저 `dp[0] = 0`을 선언해주어야 한다. 그리고 `dp[3]`이 되었을 때, 3kg 설탕 주머니를 들고 갈 수 있으므로 `dp[3] = dp[3-3] + 1`을 통해 1이 저장된다. `dp[6]`도 같은 점화식을 이용해서 `2`가 저장된다.

`number == 5`일 때는 `dp[k-number]`가 `Integer.MAX_VALUE`가 아니라면, *`(3에 의해 초기화 된 값)`* 최소 개수를 갱신한다.

예를 들어 3kg 설탕 주머니로 아래와 같이 DP 배열이 있다고 가정해보자.
```
무게 [1][2][3][4][5][6][7][8]
개수 [ ][ ][1][ ][ ][2][ ][ ]
```

이 때 `number == 5`라면 가장 먼저 `dp[5]`에 `1` 이 저장되고, `dp[8]`이 되었을 때 `dp[8-5] = dp[3]` 이기 때문에 배열에 저장된 값이 `Integer.MAX_VALUE`가 아니기 때문에 `dp[8] = dp[3] + 1`을 저장한다.

