## 오르막 수

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/11057)|오르막 수|실버 1|

### 문제 풀이

문제는 자리 수 N이 주어질 때, 해당 자리 수로 만들 수 있는 오르막 수를 최대 개수를 구하는 문제이다. 만약 `N == 1` 일 경우에 오르막 수의 최대 개수는 다음과 같이 `10개` 이다.

```
0 1 2 3 4 5 6 7 8 9
```

다음 `N == 2` 일 때는 다음과 같다.

```
00 01 02 03 04 05 06 07 08 09
11 12 13 14 15 16 17 18 19
...
88 89
99
```

즉 `1부터 10까지 더한 수`와 같다. (= 55) 바로 이 규칙을 이용해 DP 배열을 구하여 N이 주어졌을 떄, 오르막 수를 만드는 최대 개수를 구할 수 있다.
```
   0  1  2  3  4  5  6  7  8  9
1  1  1  1  1  1  1  1  1  1  1
2 10  9  8  7  6  5  4  3  2  1
```

이런식으로 2차원 DP 배열을 구할 수 있다. 세로축은 N을 의미하고, 가로축은 맨 앞에 해당 숫자가 나왔을 때, 나올 수 있는 오르막 수의 최대 개수를 의미한다. 
만약 `N == 3` 이고, 7이 맨 앞에 올 때 오르막 수의 최대 개수를 구해보자.

```
777
778
779
788
789
799
```

이제 좀 느낌을 받을 수 있다. `dp[3][7] = dp[2][7] + dp[3][6]` 란 것을 알 수 있다. 이를 바탕으로 점화식을 만들어보면,

```
dp[N][i] = dp[N-1][i] + dp[N][i-1]
```

와 같이 도출해낼 수 있다. 또한 맨 앞의 숫자가 `9`로 시작하는 경우에는 항상 1가지가 되므로 `dp[N][9]`는 항상 `1` 이다.

이를 통해 점화식을 코드로 옮겨보면

```java
if (k == 9) {
    dp[i][k] = dp[i-1][k];
} else {
    dp[i][k] = (dp[i-1][k] + dp[i][k+1]);
}
```