## 레벨 햄버거

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/16974)|레벨 햄버거|골드 5|

### 문제 풀이

먼저 버거는 `N == 0` 일 때, 패티 하나만을 갖는다. 그리고 `N >= 1` 일 때는 `번 + N-1 버거 + 패티 + N-1 버거 + 번` 의 흐름을 갖는다. 

`N == 1` 일 때, 버거의 구성은 다음과 같다.

```
BPPPB
```

`N == 2` 일 때, 버거의 구성은 다음과 같다.

```
BBPPPBPBPPPBB
```

이 때, 문제에서 답으로 출력해야 하는 것은 `X` 라는 숫자가 주어지고, 이 숫자 만큼 위에서 한 장씩 먹은 경우, 모두 먹었을 때, 패티를 먹은 개수를 출력해야 한다. 

즉, `N == 2`, `X == 7` 라고 입력했다면 출력은 `4`로 해야한다.

이 문제는 재귀함수를 통해 풀 수 있다. 먼저 `N` 이 주어졌을 때, 총 햄버거의 길이와, `N` 일 때의 패티 개수를 구해야 한다. 점화식은 다음과 같다.

```
dp[i] = dp[i-1] + 1 + dp[i-1] // 패티 점화식
layers[i] = 1 + layers[i-1] + 1 + layers[i-1] + 1 // 햄버거 총 길이 점화식
```

이렇게 계산이 필요한 값을 구하고, 분할 정복을 통해 `먹은 개수 X` 에 대해 먹은 패티의 개수를 구한다. 또한 총 길이는 구하는 방법은 `2 x layers[i-1] + 3`와 같은 공식이다. 그렇기 때문에 늘 `홀수`가 된다. 그러면 중간 패티에 대한 인덱스를 구할 때, `X >= layers[i] / 2 + 1` 이라면 중간 패티를 먹은 경우이다.

정리하면 다음과 같다.

- `X < layers[i] / 2 + 1` : 중간 패티를 기점으로 왼쪽의 패티들만 먹은 상태이다.
- `X == layers[i] / 2 + 1` : 중간 패티까지 먹은 상태이다.
- `X > layers[i] / 2 + 1` : 중간 패티 + 오른쪽 패티까지 먹은 상태이다.

이런식으로 구성을 하고, 해당되는 경우에 `layers` 의 값을 하나씩 감소시키고, `먹은 개수 X` 의 값도 해당 되는 값으로 변경 시키면 된다.

```java
public static long recursive(int N, long X) {
    if (X <= N) return 0;
    if (N == 0) return 1;

    // 왼쪽 패티
    if ((layers[N] / 2) + 1 > X) return recursive(N-1, X-1);

    // 가운데 패티까지
    else if ((layers[N] / 2) + 1 == X) return dp[N-1] + 1;
    
    // 오른쪽 패티까지
    else return dp[N-1] + 1 + recursive(N-1, X - layers[N-1] - 2);
}
```

또한, `먹은 개수 X` 는 항상 `N` 보다 커야 패티를 먹을 수 있다. `BPPPB` 와 같이 `레벨 1 버거`가 있을 때, `먹은 개수 X`는 항상 `레벨 N` 보다 커야 패티를 먹을 수 있다. 이는 다른 레벨의 햄버거와 동일하게 적용된다. 그렇기 때문에 `if (X <= N) return 0;` 을 넣어주어야 한다.