## 가장 큰 정사각형

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/1915)|가장 큰 정사각형|골드 4|

대충 문제의 접근법까지는 알았지만, 그걸 DP로 푸는 부분에서 헤맸다. 시간을 좀 여유있게 두고 재풀이가 필요한 문제이다. 먼저 정사각형을 정의하는 조건이 필요한 문제이다.

```
[1][1]
[1][1]
```

위와 같은 배열이 있을 때, `2x2 정사각형` 인것을 알 수 있다. 이 때 크기가 `1이 아닌 정사각형`을 제외하고 가장 작은 정사각형의 단위는 2x2이다. 이는 다음과 같은 식을 만족해야 한다.

```
map[i][k] == 1
map[i+1][k] == 1
map[i][k+1] == 1
map[i+1][k+1] == 1
```

위 조건을 만족해야 `2x2의 조건을 만족하는 정사각형` 임을 알 수 있다. `3x3 정사각형`은 어떨까?

```
[1][1][1]
[1][1][1]
[1][1][1]
```

만약 새로운 DP 배열을 만들어서 위 조건을 모두 만족하는 부분에 `1`을 저장하면 결과는 다음과 같다.

```
[1][1][-]
[1][1][-]
[-][-][-]
```

하지만 이런 DP 배열로는 접근할 수 없고, 힌트 없이 이 부분까지는 접근했다. 이 DP 배열에서 정사각형의 크기를 표현할 수 있어야 한다.
`길이가 2인 정사각형`에서 `길이가 3인 정사각형`을 만족시켜야 할 때, `2x2 정사각형` 4개로 `3x3 정사각형`을 만들 떄 마지막 `2x2 정사각형`의 조건을 체크할 때, 나머지 조건의 정사각형의 조건이 모두 만족하여야 한다. 

```
[A][AB][B]
[AC][ABCD][BD]
[C][CD][D]
```

이렇게 중복적으로 검사한다고 할 때, D의 조건을 검사할 때, `A`, `B`, `C` 모두 `2x2 정사각형`이어야 한다. 그리고 `D`도 조건을 만족하고 `A`,`B`,`C` 모두 `2x2 정사각형`이라면 `3x3 정사각형`이 된다. 우리는 이미 DP 배열에 `2x2 정사각형` 만족 여부를 체크해놓았다. 

```
110
1D0
000
```

위 배열에서 `D` 부분을 체크할 때, `dp[i-1][k-1]`, `dp[i-1][k]`, `dp[i][k-1]` 이 모두 `1` 이라면 `+1`을 하여 `dp[2][2]`에 `2`를 저장한다. 하지만 이렇게 하면 가장 큰 정사각형의 크기를 알 수 없으니, 각 DP 배열의 요소에 정사각형 한 변의 길이를 저장한다. 즉 이런식으로 배열이 생성된다.

```
220
230
000
```

하지만 이런식으로 DP 배열에 저장할 때, `왼쪽 위`를 기준으로 저장하게 되면 모든 칸을 탐색할 수 없거나, 특수한 조건을 추가해줘야 해서 로직이 복잡해질 우려가 있다. 이는 **오른쪽 아래를 저장하게 되면 단순하게 계산할 수 있다.** 이는 문제의 예제를 통해 설명하겠다.

**예제**
```
0 0 1 0
0 1 1 1
1 1 1 0
0 0 1 0
```

위 내용을 토대로 `DP 배열`을 생성하면

```
0 0 1 0
0 1 1 1
1 1 2 0
0 0 1 0
```

이 중 가장 큰 값의 **제곱**을 통해 `가장 큰 정사각형의 넓이`를 구할 수 있다.
