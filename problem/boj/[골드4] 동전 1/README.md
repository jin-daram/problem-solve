## 동전 1

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2293)|동전 1|골드 4|

### 문제 풀이
동전으로 세울 수 있는 최대의 경우의 수를 계속해서 누적해가는 방식이다. 동전을 중복해서 쓸 수 있기 때문에 이를 생각해야 한다.

다음은 1원의 동전으로 10원을 만드는 조합의 개수이다.

```
K  | 1 2 3 4 5 6 7 8 9 10
C  | 1 1 1 1 1 1 1 1 1 1
```

`1`, `1+1`, `1+1+1` ... 등으로 가능하니 각각 한 개씩의 경우의 수가 가능하다. 여기서 이제 2원으로 10원을 만드는 경우의 수를 누적한다.

```
// 1원으로 가능한 경우의 수
K  | 1 2 3 4 5 6 7 8 9 10
C  | 1 1 1 1 1 1 1 1 1 1

// 2원으로 가능한 경우의 수
K  | 1 2 3 4 5 6 7 8 9 10
C  | 0 1 0 1 0 1 0 1 0 1
```

하지만 이전에 1원으로 가능한 경우의 수를 기반으로 2원의 경우의 수를 계산하여야 한다. 1원고 2원으로 3원을 만드는 경우의 수는 다음과 같다.

```
1+1+1
1+2 (순서만 다른 경우의 수는 같은 경우로 본다 e.g: 1+2와 2+1)
```

즉, 1원의 누적값이 존재한 상태에서 2원으로 3원을 만드는 경우의 수를 계산하려고 할 때, 1원으로 1원을 만드는 경우의 수가 있으면 가능하다는 이야기이다.

`3원을 만드는 경우` = `1원으로 1원을 만드는 경우의 수` + `1원으로 3원을 만드는 경우의 수`

1원으로 1원을 만드는 경우의 수를 더하는 이유는 거기에 2원만 더하면 3원이 되기 때문에 같다. 다른 경우의 수도 이와 같다.

1원과 2원으로 5원을 만드는 경우의 수를 살펴보자.

```
1+1+1+1+1 
1+1+1+2
1+2+2
```
1원 5개로 5원을 만드는 경우의 수를 제외하고는 모두 마지막에 +2원이 되고, 그 이전은 모두 1원과 2원으로 3원을 만드는 경우의 수이다. 

점화식을 만들어보면 다음과 같다.

```
// C = Coin의 가치
dp[i] = dp[i] + dp[i-C]; 
```

나 같은 경우에는 가장 값어치가 적은 동전을 미리 DP 배열에 세팅해두고, 다음 동전들은 위 점화식을 사용해서 값을 갱신해나갔다. 만약 동전을 이용해서 만들어야 하는 액수 `k`가 동전의 값어치와 같다면 `dp[k] = dp[k] + 1`를 통해 갱신했다. 

핵심 코드는 다음과 같다.

```java
for (int i=1; i<coins.length; i++) {
    int coin = coins[i];
    for (int k=coin; k<=K; k++) {
        if (k == coin) {
            dp[k] = dp[k] + 1;
        } else {
            dp[k] = dp[k] + dp[k-coin];
        }
    }
}
```