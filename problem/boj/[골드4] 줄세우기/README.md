## 줄 세우기

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2631)|줄 세우기|골드 4|

### 문제 풀이

처음에 문제를 푸는 방법을 많이 고민했고, 어쩌면 수열과 관련해서 푸는 게 아닐까 라는 생각이 들었다. 이미 주어진 수열에서 `가장 적은 횟수`를 움직여 수열을 오름차순으로 만들려면, 이미 오름 차순인 수열에 대해서는 건드리지 않는게 좋다.
예를 들어 `1 4 2 3` 이라는 수열이 주어졌을 때, `1 4`, `1 2`, `1 3`이 가장 긴 증가하는 부분 수열인데, 뒤에 수를 앞의 수의 앞으로 보내지 않는 것이 좋다. 그래야 최소 횟수를 구할 수 있다. 그렇다면 주어진 수열에서 증가 하는 부분 수열에 해당 하지 않는 숫자만 움직이면 된다.

문제의 예제로 주어진

```
3 7 5 2 6 1 4
```

의 경우, 가장 긴 증가하는 부분 수열은 바로 `[3 0 5 0 6 0 0] (0은 해당하지 않는 수를 의미)` 이다. 그렇다면 저 숫자들은 유지한 체, `0`에 해당하는 순서의 숫자들만 움직이면 된다. 실제로 다른 예제들을 통해 예상해보면 모두 `전체 아이 수 (N) - 가장 긴 증가하는 부분 수열의 길이` 와 같은 횟수가 수열을 `오름차순`으로 만드는 최소 이동 횟수이다.

그렇기 때문에 `LIS`를 구한 후 그 중 가장 큰 값을 `N`에서 빼주면 된다.

```java
for (int i=1; i<N; i++) {
    for (int k=0; k<i; k++) {
        if (arr.get(k) < arr.get(i)) {
            dp[i] = Math.max(dp[i], dp[k] + 1);
        } else {
            dp[i] = Math.max(dp[i], 1);
        }
    }
}

int max = 0;
for (int i=0; i<N; i++) {
    max = Math.max(max, dp[i]);
}
System.out.println(N - max);
```

