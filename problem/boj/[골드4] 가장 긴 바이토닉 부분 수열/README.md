## 가장 긴 바이토닉 부분 수열

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/11054)|가장 긴 바이토닉 부분 수열|골드 4|

### 문제 풀이

가장 긴 바이토닉 부분 수열이라는 것은 수열이 점차 증가하거나, 감소하거나, 증가하다가 감소하는 형태를 말한다. 즉 다음과 같은 케이스들은 모두 바이토닉 수열이다.

```
[ 1, 2, 3, 2, 1 ]
[ 1, 2, 3, 4, 5 ]
[ 5, 4, 3, 2, 1 ]
```

이 때, 각각의 수열의 요소는 2개의 상태를 가질 수 있다.
증가 가능과 하강 가능의 상태 값이다.

`[ 1, 2, 3, 2, 1 ]`의 수열이 있다고 해보자. 이 떄, 수열의 3번째 요소는 다음과 같은 상태값을 가질 수 있다.

```
증가: 3
하강: 3
```

저 값의 의미는 증가할 때도 수열의 길이가 3이 가능하고, 하강할 때도 3이 가능하다는 이야기이다. 즉 수열의 4번째 요소에 어떤 요소가 오든 3이라는 길이는 무조건 포함된다는 이야기이다. 그럼 수열의 4번째 요소인 `2`는 어떨까?

```
증가: 2
하강: 4
```

증가값은 수열의 `2번째 요소 (2)`, `3번쨰 요소 (3)` 로부터는 증가할 수 없다. 즉 수열의 `1번째 요소 (1)`에서만 증가할 수 있다. 그렇기 때문에 상승값은 `[1, 2]`로 상승했을 때의 길이인 `2`다.
반면에 하강은 `3번째 요소 (3)`에서부터 가능하기 때문에 `4`가 된다. 이제 이러한 값을 구하는 알고리즘을 생각하여 구성하면 된다.

핵심 코드는 다음과 같다.

```java
for (int i=2; i<N; i++) {
    int target = numbers[i];
    dp[0][i] = 1;
    dp[1][i] = 1;
    for (int k=0; k<i; k++) {
        if (target > numbers[k]) {
            dp[0][i] = Math.max(dp[0][i], dp[0][k] + 1);
        }

        if (target < numbers[k]) {
            dp[1][i] = Math.max(dp[1][i], dp[1][k] + 1);
            dp[1][i] = Math.max(dp[1][i], dp[0][k] + 1);
        }
    }
}
```

처음 `dp[0][0]`, `dp[1][0]`, `dp[0][1]`, `dp[1][1]` 값은 정해져 있어야 한다. 

```java
if (numbers[0] > numbers[1]) {
    dp[0][1] = 1;
    dp[1][1] = 2;
} else if (numbers[0] == numbers[1]) {
    dp[0][1] = 1;
    dp[1][1] = 1;
} else {
    dp[0][1] = 2;
    dp[1][1] = 2;
}
```