## 합분해

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2225)|합분해|골드 5|

### 문제 풀이

문제는 어떠한 수 N과 K가 주어졌을 때, `0 ~ N`까지의 숫자 중에 K개로 N을 만들 수 있는 경우를 찾는 것이다. 이는 순서가 다르면 다른 경우로 취급한다. 예를 들어 `3`을 만들 때, `1+2`와 `2+1`은 다른 경우의 수이다.

`6`이라는 숫자를 2개의 숫자를 이용해 만드는 경우의 수는 다음과 같다.

```
6+0
5+1
4+2
3+3
2+4
1+5
0+6
```

총 7개다. 다음은 `6`이라는 숫자를 3개의 숫자를 이용해 만드는 경우의 수 중 일부이다.

```
6+0+0
5+1+0
4+2+0
3+3+0
2+4+0
1+5+0
0+6+0
...
```

위의 일부분은 6을 2개의 숫자로 만드는 경우의 수와 같다. 즉 `6+0`에서 `6`을 `6`을 만드는 경우의 수로 나눈 것이다. 이를 점화식으로 표현하면 다음과 같다.
```
// i = N, k = K
dp[i][k] = dp[i][k-1] + dp[i-1][k-1] + dp[i-2][k-1] + dp[i-3][k-1] + ... + dp[0][k-1]
```

즉, 푸는 구조만 생각했을 때, [부녀회장이 될테야](../[브론즈1]%20부녀회장이%20될테야/README.md)과 비슷한 구조이다. 이전 배열의 값을 다 더한 것과 같다. 내가 처음 이 방법을 생각했을 때 중복값이 있을 거라고 생각했다.

예를 들어 `dp[3][2]`의 방법은
```
3+0
2+1
1+2
0+3
```
이다. 이를 만약 `3 + 3`의 경우를 대입해본다면
```
(3+0) +3
(2+1) +3
(1+2) +3
(0+3) +3
```

으로 나뉘게 된다. 하지만 뒤에 3도 있지 않은가? 이 경우도 생각해야 한다고 했지만, 다른 번호에서 그 부분은 모두 해당하고 있다. 즉 나는 맨 마지막에 +3을 하는 모든 경우만 생각하면 됐다. 실제로 저 경우에 존재하지 않는 `3+3+0`의 케이스에는 `6+0` 에서 6을 2개로 나누는 경우에 포함되어 있다. 그렇기 때문에 문제가 없다.

핵심은 뒤에 숫자 혹은 앞에 숫자가 어떠한 것으로 끝나는 모든 경우를 계산하면 중복은 없다는 것이다. 이를 이용하면 문제를 간단히 풀 수 있다. 먼저 나는 0 ~ N의 숫자 중 N을 K개로 만드는 경우의 수를 담는 배열 `DP[]`와 이들의 누적값을 다루는 `result[]` 배열을 선언하여 총 2개의 배열울 통해 풀었다. `시간 복잡도는 N*K` 이기 때문에 `최대 40,000` 이다. 

초기값은 dp[i][1]의 값은 모두 `1`이다. 각각의 숫자를 한 개의 숫자로 만드는 방법은 N이 되는 수 밖에 없기 때문이다.
`e.g) 19의 수를 0~19의 숫자 중 1개를 사용해서 만드는 방법은 19 하나 뿐이다.` 또한 `StackOverflow`를 방지하기 위해 `long 타입 배열`을 사용했다.