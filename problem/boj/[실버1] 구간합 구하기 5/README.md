## 구간합 구하기 5

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/11660)|구간합 구하기 5|실버 1|

### 문제 풀이

테스트 케이스가 여러 개 주어지기 때문에, 매번 크기를 구하게 되면 M이 100,000까지 가능하기 때문에 속도 초과가 날 수 있다. 그래서 DP를 이용하여 동적으로 (x1, y1), (x2, y2)를 이용하여 크기를 구할 수 있어야 한다.

먼저 2차원 DP 배열을 선언한다. 그리고 각 DP 배열의 요소에는 해당 지점을 (1,1) 에서 (x2, y2)를 크기로 하는 사각형의 크기를 구한다. 그림으로 보면 다음과 같다.

```
1 5 4
1 2 3
3 2 1
```

위와 같이 문제에서 주어졌을 때, DP 배열에는 아래와 같이 들어가야 한다.
```
1  6 10
2  9 16
5 14 22
```

와 같이 DP 배열을 구성하면 된다. 바로 이 부문이 핵심인데, 주어진 배열을 한번씩 돌면서 구해야 하기 때문에 누적합을 이용한다. 내가 각각의 누적합을 구한 방법은 다음과 같다.

1. `i`가 `1~M` 까지 증가한다고 할 때, 입력으로 주어진 배열 [i][1]와 [1][i]의 누적합을 구하여 2차원 DP 배열에 저장한다.
2. `(2, 2)` 부터 `[i-1][k] + [i][k-1] + map[i][k] - dp[i-1][k-1]` 값을 구하여 2차원 DP 배열에 저장한다.
3. (2)를 배열의 `(x2, y2)` 까지 반복하여 DP 배열을 완성한다. 
4. 입력 테스트 케이스로 주어진 좌표를 활용하여 구간합을 구한다. 
    ```java
        int result = dp[x2][y2] - dp[x2][y1-1] - dp[x1-1][y2] + dp[x1-1][y1-1];
    ```

<br>

> 마지막에 추가로 dp[x1-1][y1-1]을 빼고 더하는 이유?

`dp[i][k]`에 해당하는 구간합을 구할 때, `dp[i-1][k] + dp[i][k-1]`을 한다면 `dp[i-1][k-1]`의 값이 2번 중복되어 더해졌다. 그렇기 때문에 DP 배열을 구성할 때는 빼주었다. 

다만, 두 개의 좌표를 기준으로 하는 구간합을 구할 때에는 `(1, 1)`, `(x2, y2)` 의 구간합에서 필요하지 않은 구간합을 빼는 것이기 때문에 두 번 중복되어 빼진다. 그래서 한번 더해주는 것이다.

큰 흐름은 다음 그림을 참고하면 좋다.

<img src="4.gif" width="180px">