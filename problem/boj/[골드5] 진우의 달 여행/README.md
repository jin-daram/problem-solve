## 진우의 달 여행

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/17485)|진우의 달 여행|골드 5|

### 문제 풀이

다소 코드가 복잡해지는 경향이 있는 문제이다. 문제의 가장 중요한 점은 이전에 이동한 방향은 다음에 이동하지 못한다는 것이다. 그렇기 때문에 이동에 대한 값들이 각각 필요하다. 먼저 **3차원 배열**을 통해 구현할 수 있다. 마지막 요소에 방향의 값을 넣으면 된다. 

```
왼쪽 아래로 이동 : 0
아래로 이동 : 1
오른쪽 아래로 이동 : 2
```

이런식으로 규칙을 정해두고, `dp[1][1][0]` 이라고 했을 떄 왼쪽 아래로 이동해서 `map[1][1]` 에 도달했을 떄, 최솟값을 구하면 된다. 다만 이전에 이동했던 방향을 연속으로 갈 수 없으므로, 최솟값을 구할 때, 해당 방향은 제외하고 구하면 된다. `0`은 왼쪽 아래로 이동하는 경우이기 때문에 이전 위치는 `[i-1][k+1]` 이다. 이 때 `dp[i-1][k+1][1]` 과 `dp[i-1][k+1][2]` 값 중 최솟값을 구하면 된다.

점화식을 세우면 다음과 같다.

```
dp[i][k][0] = Math.min(dp[i-1][k+1][1] + map[i][k], dp[i-1][k+1][2] + map[i][k])
```

이런식으로 각 방향에 대해 점화식을 세울 수 있다. 모든 점화식을 종합해보면 다음과 같다.

```
dp[i][k][0] = Math.min(dp[i-1][k+1][1] + map[i][k], dp[i-1][k+1][2] + map[i][k])
dp[i][k][1] = Math.min(dp[i-1][k][0] + map[i][k], dp[i-1][k][2] + map[i][k]);
dp[i][k][2] = Math.min(dp[i-1][k-1][0] + map[i][k], dp[i-1][k-1][1] + map[i][k]);
```

하지만 `k == 0` 이거나, `k == M - 1` 인 경우에는 해당 경우를 모두 처리할 수 없으니, 조건에 맞게 처리해주면 된다. 자세한 부분은 [코드](./Solution.java)를 참고해주길 바란다.
또한 `i == 0` 인 경우에는 이전 방향이 존재하지 않기 때문에 어느 방향으로도 이동할 수 있다. 그렇기 때문에 `i == 1` 일 때의 `DP 배열` 에 최솟값을 구할 때 이 점을 참고해서 구해야 한다.

나 같은 경우에는 `i == 1` 의 경우는 따로 처리해두고, 반복문은 `i == 2` 부터 시작해서 구했다.
