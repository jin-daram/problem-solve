## 뮤탈 리스크

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/12869)|뮤탈 리스크|골드 4|

### 문제 풀이

뮤탈 리스큰 한 대상을 공격하면 주변에 있는 대상의 유닛에게 튕겨져 공격한다. 

- 뮤탈 리스크는 첫 번쨰 대상에게 9의 데미지를 준다.
- 뮤탈 리스크는 두 번째 대상에게 3의 데미지를 준다.
- 뮤탈 리스크는 세 번째 대상에게 1의 데미지를 준다.

SCV `N 마리 (1 <= N <= 3)` 가 주어지고 뮤탈 리스크가 공격했을 때, SCV가 모두 파괴되는 최소 공격 횟수를 구하는 문제이다. 예전에 풀기를 도전했지만, 접근이 어려워 일주일 뒤에 다시 풀어보는 문제이다. 

먼저 뮤탈은 다음과 같이 공격할 수 있다.

```
1 2 3

9 3 1
9 1 3
3 1 9
3 9 1
1 3 9
1 9 3
```

각각 공격 대상의 순서에 맞는 데미지 표이다. 그리고 가장 빠른 답을 도출해내야 하기 때문에 BFS를 이용해야 한다. 핵심적인 건 저런 공격 패턴을 구조화하는 것이다. 

```java
static class Attack {
    int[] hp;
    int[] damage;
    int count;
    
    public Attack(...) {
        ...
    }
}
```

먼저 Queue를 활용해야 하기 때문에 위와 같은 `Attack` 클래스를 만들어 활용했다. 초기 Queue에는 주어진 SCV 체력과 뮤탈리스크 데미지 표를 `Attack` 객체로 만들어 Queue에 삽입한다.

```java
...
Queue<Attack> queue = new LinkedList<>();

for (int i=0; i<damages.length; i++) {
    queue.add(scv.clone(), damages[i], 0);
}
...
```

그리고 Queue 에서 하나씩 `Attack` 객체를 빼면서 SCV들의 체력에 데미지를 적용하고, SCV들이 모두 파괴되지 않았다면 줄어든 SCV들의 체력을 이용하여 또 다시 `Attack` 객체를 생성하여 Queue에 넣는다. 이런식으로 계속 진행하다가 처음으로 SCV들이 모두 파괴 되는 때에, Count를 출력하면 된다. 

하지만 SCV의 최대 체력은 60이다. SCV 체력이 모두 60 이라면 너무나 많은 경우의 수가 생긴다. 

이 때, 시간 초과를 방지하기 위해서 중복된 값을 제거해야 한다. 여러 가지 방법으로 SCV들의 체력을 줄었을 때, 반드시 모든 SCV 체력의 구조가 다른 공격 방법과 같아지는 상황이 나온다. 

그런 상황에서는 똑같은 체력을 여러번 계산하기 때문에 중복 계산이 이루어져, 성능이 감소한다. 

이런 현상을 방지하기 위해 `visited 3차원 배열`을 만들어서 처리한다.

```java
...
else if (!visited[hp[0]][hp[1]][hp[2]]) {
    visited[hp[0]][hp[1]][hp[2]] = true;
    for (int i=0; i< damages.length; i++) {
        queue.add(new Attack(hp.clone(), damages[i], count + 1));
    }
}
...
```

