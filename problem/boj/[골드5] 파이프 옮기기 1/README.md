## 파이프 옮기기 1

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/17070)|파이프 옮기기 1|골드 5|

### 문제 풀이
먼저 파이프는 3가지 상태가 있다. 
1. **가로**
2. **세로**
3. **대각선**

파이프가 `가로`로 있는 경우에는 끝점을 기준으로 ➡️ 와 ↘️ 으로만 이동할 수 있다.

```
// O는 파이프가 존재하는 위치
// A, B ... N로 갈 수 있음을 의미한다.
[O][O][A]
[X][X][B]
[X][X][X]
```

파이프가 `세로`로 있는 경우에는 끝점을 기준으로 ⬇️ 와 ↘️ 으로만 이동할 수 있다.

```
[X][O][X]
[X][O][X]
[X][A][B]
```

파이프가 `대각선`으로 있는 경우에는 모든 방향으로 진행할 수 있다. (➡️ ⬇️ ↘️)

```
// 대각선으로 있는 파이프의 경우 4칸을 차지한다.
[O][O][X]
[O][O][B]
[X][C][A]
```

어떤 칸 `(a, b)`가 주어졌을 때, 해당 칸을 올 수 있는 해당 칸의 `위`, `좌측`, `좌측 위 대각선`에 따라 다르다. 각 파이프는 상태를 가지기 때문에 3차원을 배열울 통해 각 칸의 상태를 추가한다. 각 상태는 `가로`, `세로`, `대각선`이 가능하기 때문에 `3가지` 로 제한할 수 있다.
`dp[N][N][3]`

(1) 가로로 오는 경우
먼저 `(a, b)`에 가로로 오려면 `(a, b-1)`에 위치의 파이프가 `가로` 상태이거나, `대각선`상태이어야 한다.

(2) 세로로 오는 경우
`(a, b)`에 세로로 오려면 `(a-1, b)`에 위치의 파이프가 `세로` 상태이거나, `대각선` 상태이어야 한다.

(3) 대각선으로 오는 경우
`(a, b)`에 대각선으로 오려면 `(a-1, b-1)`에 위치의 파이프가 `가로` 상태이거나 `세로` 상태 이거나, `대각선` 상태이어야 한다.

이를 DP 식으로 표현하면 다음과 같다. `3차원 배열의 마지막 요소 : (0=가로, 1=세로, 2=대각선)`

```
dp[i][k][0] = dp[i][k][0] += dp[i][k-1][2] + dp[i][k-1][0]
dp[i][k][1] = dp[i][k][1] += dp[i-1][k][2] + dp[i-1][k][1]
dp[i][k][2] = dp[i][k][2] += dp[i-1][k-1][0] + dp[i-1][k-1][1] + dp[i-1][k-1][2];
```

이런식으로 하면 (N, N) 일 때, 파이프를 옮기는 방법의 수를 구할 수 있다. 하지만 문제에는 벽이 주어진다. 벽은 map[][] 2차원 배열에서 `1`이라는 값으로 표현되며 파이프를 움직일 때, 포함되는 칸에 `1`이 포함되어 있으면 파이프를 옮길 수 없다. `가로`, `세로` 상태의 파이프는 움직이려는 칸에만 `1`이 포함되지 않으면 되지만, `대각선` 상태의 파이프는 4칸을 차지하기 때문에 움직이려는 위치 주위의 칸들이 모두 `1`을 가지면 안된다.

코드를 통해 다음과 같이 조건을 분기할 수 있다.


```java
if (map[i-1][k-1] != 1 && map[i][k-1] != 1 && map[i-1][k] != 1) { // 대각선 이동
    dp[i][k][2] += dp[i-1][k-1][0] + dp[i-1][k-1][1] + dp[i-1][k-1][2];
}

if (map[i-1][k] != 1) { // 세로 이동
    dp[i][k][1] += dp[i-1][k][2] + dp[i-1][k][1];
}

if (map[i][k-1] != 1) { // 가로 이동
    dp[i][k][0] += dp[i][k-1][2] + dp[i][k-1][0];
}
```

이런식으로 DP 배열의 값들을 계속 채워서, 마지막의 dp[N][N][0~2]의 값을 더해 출력하면 된다.