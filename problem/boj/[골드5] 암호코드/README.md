## 암호 코드

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/2011)|암호코드|골드 5|

### 문제 풀이
`"BEAN"` 과 같은 문자열을 암호화 할 때 그 방식을 A = 1, B = 2 , ... , Z = 26로 표현해서 암호화 할 수 있다. 하지만 이 방식은 큰 문제가 있는데 바로 여러 방식으로 해석될 수 있다는 것이다.

`121` 이라는 숫자는 `[1,2,1](ABA)`, `[12,1](LA)`, `[1,21](AU)` 로 해석될 수 있다. 이때 문제는 나올 수 있는 해석의 가짓 수를 구하는 문제이다. `121` 이라는 암호는 3가지로 해석될 수 있다.

DP를 이용해서 풀 수 있는데, `i`는 자릿수를 의미하고, `dp[i]`는 해당 자릿 수에 해석될 수 있는 가짓수를 의미한다. 

예제의 입력인 `25114`를 예로 들면, 

`dp[1]` = 1 `(2)`
`dp[2]` = 2 `([2,5], [25])`
`dp[3]` = 2 `([2,5,1], [25,1])`

와 같이 볼 수 있다. 여기서 점화식을 세울 때 주요 포인트는 `i`가 증가함에 따라 새로운 숫자가 붙을 때, 그 전 마지막 숫자와 붙었을 때, 표현할 수 있느냐 없느냐가 중요한 점이다. 만약 표현할 수 없으면 `dp[i]`는 `dp[i-1]`만큼만 가짓수로 해석할 수 있다. 

`[2,5] -> [2,5,1] = 5와 1은 붙을 수 없음. => dp[i] = dp[i-1]`

하지만 붙을 수 있는 경우도 있다. 숫자를 `[2, 1, 6]` 일 떄로 생각해보자.
이 때 추가되는 건 `[2, 16]` 과 같은 해석이다. 즉, 이전 수와 붙을 수 있으면 그 앞 `dp[i-2]`와 똑같은 해석의 수로 추가될 수 있다.
`[2, 1] => [2, 1, 6] => 1과 6은 붙을 수 있음. => dp[i] = dp[i-2]`

이 두 가지를 바탕으로 점화식을 세워서 코드를 짜면 된다.

```java
if (currentNumber != 0) {
    dp[i] += dp[i - 1] % 1000000;
}

if (merged <= 26 && previousNumber != 0) {
    dp[i] += dp[i - 2] % 1000000;
}
```

추가적으로 `0`이 오는 상황도 고려해야 한다. 즉 `0`에 의해 해석할 수 있느냐와 없느냐가 이루어지기 때문에 아래와 같은 상황을 고려해서 문제를 풀어야 한다.kv

- `0`으로 시작하면 해석할 수 없다. => `0 출력`
- 이전 숫자와 합칠 수 없으면 해석할 수 없다. => `0 출력`