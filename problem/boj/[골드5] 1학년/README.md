## 1학년

|풀이 사이트|문제이름|난이도|
|:---:|:---:|:---:|
|[백준](https://www.acmicpc.net/problem/5557)|1학년|골드 5|

### 문제 풀이

맨 처음 생각했던 풀이법은 각각의 경우의 수를 모두 계산하는 것이었다. 다음 처럼 예제가 주어졌을 때.

```
8 3 2 4 8 7 2 4 0 8 8
```

`8 + 3`, `8 - 3`을 각각 저장하고, 
`11 + 2`, `11 - 2`, `5 + 2`, `5 - 2`를 저장하고 이런 방식으로 계산했다. 하지만 당연하게도 시간복잡도가 너무 커져, 시간 초과가 날 가능성이 많았다. 문제에서 아무리 범위를 `0 ~ 20` , `음수 제외` 를 잡았다고 하더라도 `0`을 연속해서 쓰게되면 시간 복잡도 문제가 나서 해당 방법으로 풀 수 없는 문제였다. 

```
# 시간 복잡도가 2^N 만큼 커진다.
   + 0 
  0
 + - 0
0   
 - + 0
  0
   - 0
```

시간 복잡도가 크지 않으면서, 모든 경우의 수를 탐색할 수 있는 방안은 바로 2차원 배열을 이용하는 방법이었다. 

```
X 0 1 2 3 4 5 6 7 8 9 
0 0 0 0 0 0 0 0 0 0 0
1 0 0 0 0 0 0 0 0 1 0
2 0 0 0 0 0 0 0 0 0 0
3 0 0 0 0 0 0 0 0 0 0
4 0 0 0 0 0 0 0 0 0 0
5 0 0 0 0 0 0 0 0 0 0
6 0 0 0 0 0 0 0 0 0 0
.
.
.
```
`dp[i][k]` 를 선언해서 `i번째` 까지의 숫자일 때 `k`가 될 수 있는 경우의 수를 구한다.

예를 들어 `dp[3][2]`면 주어진 숫자를 `3번째` 숫자까지 포함시켰을 때, `2를 만들 수 있는 경우의 수`이다.

이런식으로 2차원 배열을 만들어서 예제를 구하게 되면 N * 20의 시간 복잡도로 문제를 해결할 수 있다.

`i = 1` 일 때에는 처음 숫자에 해당하는 배열에 1 값을 집어 넣고, 그 다음부터는 0이 아닌 배열 값을 찾으면 i번째에 해당하는 숫자를 더하고 뺀 배열의 인덱스에 그 값을 더한다.

예는 다음과 같다. 

```
X 0 1 2 3 4 5 6 7 8 9 10 11
0 0 0 0 0 0 0 0 0 0 0 0  0
1 0 0 0 0 0 0 0 0 1 0 0  0
2 0 0 0 0 0 1 0 0 0 0 0  1
```

예제에서 `8 -> 3` 이라는 숫자가 올 때, 그 숫자 사이에는 `+` 와 `-` 가 올 수 있다. 그래서 `i = 2` 일 때, `5` 와 `11` 이라는 index에 `dp[1][8]`의 값을 더한다. 

이 때, `dp[1][8]`을 더하는 이유는 그 값이 만들어지는 경로는 이전 경로의 경우의 수와 동일하다. 만약 어떤 값이 만들어지는 경로가 2개 일 수 있다. 

예시)
```
8 0 1 9
```

이러한 예시가 있을 때, 8 + 0, 8 - 0 이 가능하다. 하지만 결과는 둘 다 8로 똑같다. 이를 DP 배열로 묘사하면,

```
X 0 1 2 3 4 5 6 7 8 9 10 11
0 0 0 0 0 0 0 0 0 0 0 0  0
1 0 0 0 0 0 0 0 0 1 0 0  0
2 0 0 0 0 0 0 0 0 2 0 0  0
```

그리고 다음 세 번쨰 숫자인 `1`를 계산할 때, `9`가 되는 경우의 수는 다음과 같다.

- `9 + 0 + 1`
- `9 - 0 + 1`

그렇기 때문에 이전 경로의 경우의 수를 더하여야 한다.

이를 코드로 표현하면 다음과 같다.

```java
for (int k=0; k<=20; k++) {
    if (dp[i-1][k] != 0) {
        if (k + number <= 20)
            dp[i][k + number] += dp[i-1][k];
        if (k - number >= 0) {
            dp[i][k - number] += dp[i-1][k];
        }
    }
}
```

여기서 `dp[i-1][k]`가 이전 경로가 만들어지는 경우의 수이다. 이 문제는 조금 힌트를 얻어서 풀었기 때문에 시간이 지난 후에 다시 풀어보도록 해야겠다.